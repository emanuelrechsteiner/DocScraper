---
url: https://supabase.com/blog/postgres-full-text-search-vs-the-rest
scraped_at: 2025-05-25T08:52:02.685870
title: Postgres Full Text Search vs the rest
---

  1. We use cookies to collect data and improve our services. [Learn more](https://supabase.com/privacy#8-cookies-and-similar-technologies-used-on-our-european-services)
[Learn more](https://supabase.com/privacy#8-cookies-and-similar-technologies-used-on-our-european-services)•Privacy settings
Accept Opt out Privacy settings


[![Supabase Logo](https://supabase.com/_next/image?url=https%3A%2F%2Ffrontend-assets.supabase.com%2Fwww%2Fd218d9190b87%2F_next%2Fstatic%2Fmedia%2Fsupabase-logo-wordmark--light.daaeffd3.png&w=256&q=75&dpl=dpl_9xPTPeSUKoDuygMmT5sPj6DB4mgG)![Supabase Logo](https://supabase.com/_next/image?url=https%3A%2F%2Ffrontend-assets.supabase.com%2Fwww%2Fd218d9190b87%2F_next%2Fstatic%2Fmedia%2Fsupabase-logo-wordmark--dark.b36ebb5f.png&w=256&q=75&dpl=dpl_9xPTPeSUKoDuygMmT5sPj6DB4mgG)](https://supabase.com/)
  * Product 
  * Developers 
  * [Enterprise](https://supabase.com/enterprise)
  * [Pricing](https://supabase.com/pricing)
  * [Docs](https://supabase.com/docs)
  * [Blog](https://supabase.com/blog)


[83.3K](https://github.com/supabase/supabase)[Sign in](https://supabase.com/dashboard)[Start your project](https://supabase.com/dashboard)
Open main menu
[Back](https://supabase.com/blog)
[Blog](https://supabase.com/blog)
# Postgres Full Text Search vs the rest
14 Oct 2022
•
14 minute read
[![Victor avatar](https://supabase.com/_next/image?url=https%3A%2F%2Fgithub.com%2Ft3hmrman.png&w=96&q=75&dpl=dpl_9xPTPeSUKoDuygMmT5sPj6DB4mgG)VictorGuest Author](https://github.com/t3hmrman)
![Postgres Full Text Search vs the rest](https://supabase.com/_next/image?url=%2Fimages%2Fblog%2Fpostgres-fts-vs-the-rest%2Fpostgres-full-text-search.jpg&w=3840&q=100&dpl=dpl_9xPTPeSUKoDuygMmT5sPj6DB4mgG)
Postgres is one of the best F/OSS databases partly because of its immense feature-set.
One of my favorite Postgres features is [Full Text Search](https://supabase.com/docs/guides/database/full-text-search) (FTS). Search is a common requirement of applications. Well-known search engines like [Solr](https://solr.apache.org/) and [ElasticSearch](https://www.elastic.co/elasticsearch) are often a first choice, but with Postgres in your stack you've got a great chance for [Pareto improvement](https://en.wikipedia.org/wiki/Pareto_principle) at low complexity cost.
Many projects function just fine with Postgres Full Text Search and other [built-in](https://www.postgresql.org/docs/current/contrib.html) extensions like [trigram search (`pg_trgm`)](https://www.postgresql.org/docs/current/pgtrgm.html). [GitLab's blog has a great article](https://about.staging.gitlab.com/blog/2016/03/18/fast-search-using-postgresql-trigram-indexes/) on their use of Trigram indices to speed up search.
## Search Engines: The Next Generation[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#search-engines-the-next-generation)
These days, the debate isn't _just_ Postgres versus Solr or ElasticSearch, a new generation of F/OSS search engines has arrived. To name a few:
  * [MeiliSearch](https://www.meilisearch.com/)
  * [OpenSearch](https://opensearch.org/)
  * [SQLite FTS](https://www.sqlite.org/fts5.html)
  * [Typesense](https://typesense.org/)


Well OK, some of these engines aren't _quite_ new; SQLite is stable and has supported the search use-case for a while and OpenSearch is a fork of ElasticSearch. While not new, both are worth comparing as choices in front of engineers today (spoiler alert: we're going to compare them).
These search engines are all impressive, but it's hard to evaluate these options in a `VACUUM`.
If Postgres is already your main database, then it's probably easier to integrate than anything else. But would it be _better_ to take on more complexity by choosing a dedicated search engine?
While search is an endlessly complicated problem and all of these tools are configurable, a comparison of minimal setup and tuning should yield some interesting insights.
Before we get into it though, a _brief_ primer on what "Full Text Search" _means_ , in Postgres land.
## A whirlwind tour through FTS in Postgres[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#a-whirlwind-tour-through-fts-in-postgres)
If we want to compare other solutions to Postgres FTS, we'd better review how to set up and use [Postgres FTS](https://www.postgresql.org/docs/current/textsearch.html)!
### Wrangling your existing data[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#wrangling-your-existing-data)
Imagine you have some information to search through, stored in your main database.
Maybe a `movies` table with a structure like this:
`
1
	create table movies (
2
	id bigint primary key generated by default as identity,
3
	title text not null,
4
	original_title text not null,
5
	overview text not null,
6
	created_at timestamptz not null default now()
7
);
`
While you're inserting data you might perform `INSERTs` like this one:
`
1
insert into movies (
2
	title,
3
	original_title,
4
	overview
5
)
6
values
7
(
8
	"Avengers: Age of Ultron",
9
	"Avengers: Age of Ultron",
10
	"When Tony Stark tries to jumpstart a dormant peacekeeping program, things go awry and Earth’s Mightiest Heroes are put to the ultimate test as the fate of the planet hangs in the balance. As the villainous Ultron emerges, it is up to The Avengers to stop him from enacting his terrible plans, and soon uneasy alliances and unexpected action pave the way for an epic and unique global adventure.",
11
);
`
### Basic searching with select and like[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#basic-searching-with-select-and-like)
With nothing but the raw data in your database, we can actually do some _basic_ searching using `select` and comparison tools like `like`.
`
1
select
2
 *
3
from movies
4
where title like '%Avengers%' or overview like '%Avengers%';
`
The `LIKE` [operator](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) as used in the query above will match _only_ the term "Avengers", but it will match it in any part of a given row's `title` or `overview`.
We can hack around this basic functionality and make it a bit more robust:
  * Storing the text as [case insensitive text (`citext`)](https://www.postgresql.org/docs/current/citext.html)
  * Combining the text that will be searched into one column
  * Using a [GIN index](https://www.postgresql.org/docs/14/indexes-types.html#INDEXES-TYPES-GIN)


Our "v0" would be better, but using `like` isn't quite what people mean when they ask for _robust_ full text search. **Not a bad first version, but Postgres can do much better.**
### Robust Full Text Search with Postgres[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#robust-full-text-search-with-postgres)
Postgres has built-in [Full Text Search](https://www.postgresql.org/docs/current/textsearch.html) which we can use instead of cobbling together our own with `like`.
Luckily for us, [the Postgres FTS documentation](https://www.postgresql.org/docs/current/textsearch.html) is quite extensive, containing lots of information on the all-important [Postgres search data types: `tsvector` and `tsquery`](https://www.postgresql.org/docs/current/datatype-textsearch.html).
State of the art search engines like [Solr](https://solr.apache.org/) do things to make searches work well:
  * [Stemming](https://en.wikipedia.org/wiki/Stemming) ("jumped", "jumper" -> "jump")
  * [Lemmatization](https://en.wikipedia.org/wiki/lemmatization) ("better" -> "good")
  * Result Ranking configuration
  * Search by [edit distance](https://en.wikipedia.org/wiki/Levenshtein_distance)
  * Vector based similarity (which you might use for a basic recommendation system)


Postgres FTS does not do _all_ of the things a purpose-built search engine can do, but Postgres can produce very good results with decent performance.
## A working Postgres FTS setup[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#a-working-postgres-fts-setup)
Integrating Full Text Search into our imaginary movies table is as simple as executing the following:
`
1
-- Add a generated column that contains the search document
2
alter table movies
3
	add column fts_doc_en
4
	generated always as to_tsvector (
5
		'english', title || ' ' || original_title || ' ' || overview
6
	)
7
	stored;
89
-- Create a GIN index to make our searches faster
10
create index movies_fts_doc_en_idx
11
	on movies
12
	using gin (fts_doc_en);
`
Postgres supports even more features like [facilities for ranking search results](https://www.postgresql.org/docs/current/textsearch-controls.html#TEXTSEARCH-RANKING) but for now we'll simply use `title`, `original_title`, and `overview` as they are.
`
1
select
2
	* from movies
3
where doc_en @@ websearch_to_tsquery('english', 'Avengers');
`
## Comparable FTS engines[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#comparable-fts-engines)
Now that we've got a grasp on what FTS is and how it's used in Postgres, let's discuss a few of the alternative solutions Postgres can be compared to.
As you might expect, this isn't an exhaustive list of FTS engines, there are many more that we're not covering here (If you've got another search engine you'd like to see featured, [file an issue](https://github.com/VADOSWARE/fts-benchmark/issues)).
### SQLite FTS[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#sqlite-fts)
[SQLite](https://www.sqlite.org/) is arguably the most widely deployed database in the world. SQLite is a library that produces and manages single file (or in-memory) databases that run on phones, planes, laptops, kiosks, Raspberry Pis, and everything in between.
Much like Postgres, SQLite is an excellent F/OSS project that has adopted the ability to perform Full Text Search.
The [SQLite FTS documentation](https://www.sqlite.org/fts5.html) is extensive, and the FTS subsystems have undergone a few version upgrades -- [FTS 3/4](https://www.sqlite.org/fts3.html) and [SQLite FTS 5](https://www.sqlite.org/fts5.html) are both options.
For our experiments we'll use SQLite FTS5.
### TypeSense[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#typesense)
[TypeSense](https://typesense.org/) is a relatively new project that focuses on _lightning fast_ , typo-tolerant open source search. Typesense boasts a high performance C++ codebase, promising nearly instant search results.
TypeSense provides many demos with example datasets available for query, which you can try out:
  * [32MM songs from MusicBrainz](https://songs-search.typesense.org/)
  * [28M books from OpenLibrary](https://books-search.typesense.org/)
  * [XKCD comic search by topic](https://xkcd-search.typesense.org/)


Typesense quite ambitiously brands itself as the "Algolia" and "Elasticsearch" alternative, offering to solve your search problems without requiring a PhD.
### MeiliSearch[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#meilisearch)
[MeiliSearch](https://www.meilisearch.com/) is a new search engine written from the ground up in [Rust](https://rust-lang.org/), which also promises _lightning fast_ searches, flexibility, and typo tolerance.
MeiliSearch has [extensive documentation](https://docs.meilisearch.com/), boasts an easy to use yet extendable architecture, and is well supported by a large community and team.
### OpenSearch[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#opensearch)
AWS [OpenSearch](https://opensearch.org/) is AWS's answer to ElasticSearch's license changes. While opinions are varied, ElasticSearch built a great piece (formerly Apache 2.0 licensed) piece of software, and the AWS fork represents at least a _stale_ measure of ElasticSearch's capabilities.
OpenSearch is the _same_ as ElasticSearch (since the fork) but as it's license is much more permissive, it's the easy choice as a comparison to Postgres.
In production make sure to evaluate ElasticSearch versus OpenSearch (or other solutions) sufficiently for your use case.
## Testing our FTS solutions[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#testing-our-fts-solutions)
Well, how do we test performance of these disparate complex systems on an infinitely redefinable, hard-to-solve problem? By sticking to the use cases.
Any search engine has two jobs:
  * Ingest information (usually referred to as "documents")
  * Return documents that match user queries


Ingesting information _can_ be important, but "search engine performance" usually refers to the second step - taking queries and outputting results.
That is to say, the primary concern is assuming a cluster already has proper data loaded on to it, how fast can it deliver the relevant results for a user-submitted query?
We'll focus on the end-user-centric meaning of performance here (query speed).
### Getting a dataset[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#getting-a-dataset)
[Hugging Face](https://huggingface.co/) has a [32MB movie data set](https://huggingface.co/spaces/Kamand/Movie_Recommendation/blob/main/movies_metadata.csv). We're interested in the follow columns in this data set:
  * `title`
  * `original_title`
  * `overview`


Postgres is capable of loading CSVs, but since we'll be using other search engines as well, let's convert to format that's much easier to use and process - [Newline Delimited JSON](https://dataprotocols.org/ndjson/).
After a few lines of code and one [`csv2ndjson.mjs` script](https://github.com/VADOSWARE/fts-benchmark/blob/main/src/util/csv2ndjson.mjs) later, we have a `movies.ndjson.json` full of JSON documents that we can easily ingest into any search engine (or other database for that matter!).
### Inserting the data[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#inserting-the-data)
Each system ingests data slightly differently, but with a little scripting we can paper over the differences.
[The code](https://github.com/VADOSWARE/fts-benchmark) contains a scheme of "drivers" which are minimal ES6 modules.
Here's an example of the `ingest` function used for Postgres (with [`slonik`](https://github.com/gajus/slonik) as our DB driver):
`
1
// Ingesting search documents
2
async function ingest({ document, pool }) {
3
 // Ignore rows without proper release dates
4
 if (document.release_date.trim().length === 0) {
5
  return
6
 }
78
 await pool.query(sql`
9
insert into movies (
10
	id, 
11
	title, 
12
	original_title, 
13
	overview, 
14
	released_at
15
)
16
values
17
(
18
	${document.id},
19
	${document.title},
20
	${document.original_title},
21
	${document.overview},
22
	${new Date(document.release_date).toISOString()}::timestamptz
23
)
24
on conflict (id) do update set
25
 title=${document.title}, 
26
	original_title=${document.original_title}, 
27
	overview=${document.overview}, 
28
	released_at=${new Date(document.release_date).toISOString()}::timestamptz
29
;
30
`)
31
}
`
The [repo](https://github.com/VADOSWARE/fts-benchmark/) contains the complete code for Postgres as well as the other search engines, written in much this same fashion.
### Picking a set of queries[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#picking-a-set-of-queries)
This part is somewhat arbitrary - I've gotten a list of queries here that one might search for in terms of movies:
`
1
"super hero"
2
"superhero"
3
"superman"
4
"suprman"
5
"love"
6
"world war"
7
"spy"
8
"romance"
9
"comedy"
10
"awakening"
`
Thanks to [boinboing.net's article from 2018](https://boingboing.net/2018/04/30/the-most-common-words-in-movie.html), there are some words that show up quite often in movie titles that we can search for.
The data set isn't very big, but doing all these searches in quick succession should be enough to get a realistic performance baseline.
### Running the queries[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#running-the-queries)
Similar to ingesting data, all the search engines take slightly different input for queries, so we'll change our simple string queries into whatever the relevant search engine expects to receive.
Here's what that script looks like for Postgres:
`
1
// Querying search phrases
2
async function query({ phrase, pool }) {
3
 const results = await pool.query(sql`
4
select id, title
5
from movies
6
where fts_doc_en @@ websearch_to_tsquery('english', ${phrase}::text)
7
`)
8
 const ids = results.rows.map((r) => r.id)
9
 return ids
10
}
`
No surprises there, just like the Postgres FTS example from earlier.
## Automating our toil[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#automating-our-toil)
Once we've combined our scripting magic with some `Makefile` incantations, running the queries produces output like this:
`
1
TIMING=true FTS_ENGINE=pg make query
2
[info] importing driver from [./pg.mjs]
3
[info] finished initializing driver [pg]
4
[info] processing lines in [/path/to/pg-fts-benchmark/search-phrases.ndjson.json]...
5
[timing] phrase [super hero]: returned [34] results in 3.132471.ms
6
[timing] phrase [superhero]: returned [86] results in 1.180798.ms
7
[timing] phrase [superman]: returned [47] results in 0.912615.ms
8
[timing] phrase [suprman]: returned [0] results in 0.781712.ms
9
[timing] phrase [love]: returned [5417] results in 19.088668.ms
10
[timing] phrase [world war]: returned [834] results in 2.902097.ms
11
[timing] phrase [spy]: returned [349] results in 1.497892.ms
12
[timing] phrase [romance]: returned [630] results in 1.91661.ms
13
[timing] phrase [comedy]: returned [1213] results in 2.534538.ms
14
[timing] phrase [awakening]: returned [210] results in 2.443748.ms
15
[info] successfully processed [10] lines
`
Right off the bat we can see that Postgres is plenty quick! Some results are quite obvious - as you might expect, "love" is _quite_ a common search result.
## Results[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#results)
With the `ingest` and `query` machinery defined for the search engines, it's easy to get some results.
LatencyNumber of resultsAverage latencyRaw data
04080120160Latency (ms)awakeningcomedyloveromancespysuperherosuperherosupermansuprmanworldwar
  * pg
  * meilisearch
  * typesense
  * sqlite-disk
  * sqlite-mem
  * opensearch


## What does the data tell us?[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#what-does-the-data-tell-us)
There's a _lot_ of tuning left undone here, but a few points stand out right away:
  * Even when consuming similar content, engines can produce different results, but generally ratios between queries on the same engine should be consistent.
  * Postgres FTS is quite close performance-wise to many other solutions, at least in their default configuration.
  * Only Typesense and MeiliSearch properly handled mis-spellings (the "suprman" query).
  * Typesense was relatively strict with matches compared to other engines.
  * OpenSearch was _very_ fast with ingest, but the default configuration doesn't index misspellings.
  * In-memory SQLite is by far the fastest, and PG isn't too far behind for this small data set.


## Feedback from the other products[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#feedback-from-the-other-products)
Since this is a benchmark, we felt it was fair to give the other products an opportunity to give their feedback.
### Meilisearch[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#meilisearch-1)
> I agree that using PG in simple use cases is an excellent way to be pragmatic. Unfortunately, PG will never be able to offer you a search experience like the one you could have with Meilisearch. Meilisearch has perfect management of typos and searches by prefix, allowing a search at each keystroke. Enhanced relevancy with rules such as the number of words present, the importance of the attribute, the proximity of the terms searched in the document, and custom parameters. The ability to mix textual, geographic, and facet searches. Meilisearch automatically understands almost all languages with the possibility of having synonyms and stop words. Meilisearch has an incredible performance even on large volumes of data, and no backend proxy is needed, thanks to complete API Key management.
_Quentin de Quelen, Meilisearch CEO_
### Typesense[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#typesense-1)
> Some more context around Typesense's behavior: how loose or exact matches are done are configurable in Typesense. For eg, you can configure the number of typos that are accounted for (num_typos), and when typo tolerance should kick-in, only if a configurable amount of results are not found (typo_tokens_threshold). For multi keyword searches, you can configure Typesense to expand the search by dropping some of the keywords, until at least a configurable number of search results are found (drop_tokens_threshold). We've chosen specifically to keep the search tight because we received feedback from users that some results were confusing if we let the defaults be too loose.
_Jason Bosco, Typesense CEO_
## Wrap-up[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#wrap-up)
While this certainly isn't "big data", it looks like Postgres has very much held it's own, even without too much wrangling/tuning. Postgres is clearly more than capable of delivering _good enough_ search for this very basic case.
Special purpose systems are expected to out-perform a more general system like Postgres, but clearly result quality and search speed provided Postgres is likely to be _good enough_ for many use cases, and is “complexity neutral” -- no new systems needed!
## More Postgres resources[#](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#more-postgres-resources)
  * [Postgres WASM by Snaplet and Supabase](https://supabase.com/blog/postgres-wasm)
  * [Choosing a Postgres Primary Key](https://supabase.com/blog/choosing-a-postgres-primary-key)
  * [Implementing "seen by" functionality with Postgres](https://supabase.com/blog/seen-by-in-postgresql)
  * [Partial data dumps using Postgres Row Level Security](https://supabase.com/blog/partial-postgresql-data-dumps-with-rls)
  * [Postgres Views](https://supabase.com/blog/postgresql-views)
  * [Realtime Postgres RLS on Supabase](https://supabase.com/blog/realtime-row-level-security-in-postgresql)


Share this article
[](https://twitter.com/intent/tweet?url=https%3A%2F%2Fsupabase.com%2Fblog%2Fpostgres-full-text-search-vs-the-rest&text=Postgres%20Full%20Text%20Search%20vs%20the%20rest)[](https://www.linkedin.com/shareArticle?url=https%3A%2F%2Fsupabase.com%2Fblog%2Fpostgres-full-text-search-vs-the-rest&text=Postgres%20Full%20Text%20Search%20vs%20the%20rest)[](https://news.ycombinator.com/submitlink?u=https%3A%2F%2Fsupabase.com%2Fblog%2Fpostgres-full-text-search-vs-the-rest&t=Postgres%20Full%20Text%20Search%20vs%20the%20rest)
[Last postsupabase-js v2 Released20 October 2022](https://supabase.com/blog/supabase-js-v2-released)
[Next postSupabase Beta September 20225 October 2022](https://supabase.com/blog/supabase-beta-update-september-2022)
[postgres](https://supabase.com/blog/tags/postgres)[planetpg](https://supabase.com/blog/tags/planetpg)
On this page
  * [Search Engines: The Next Generation](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#search-engines-the-next-generation)
  * [A whirlwind tour through FTS in Postgres](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#a-whirlwind-tour-through-fts-in-postgres)
    * [Wrangling your existing data](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#wrangling-your-existing-data)
    * [Basic searching with select and like](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#basic-searching-with-select-and-like)
    * [Robust Full Text Search with Postgres](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#robust-full-text-search-with-postgres)
  * [A working Postgres FTS setup](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#a-working-postgres-fts-setup)
  * [Comparable FTS engines](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#comparable-fts-engines)
    * [SQLite FTS](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#sqlite-fts)
    * [TypeSense](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#typesense)
    * [MeiliSearch](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#meilisearch)
    * [OpenSearch](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#opensearch)
  * [Testing our FTS solutions](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#testing-our-fts-solutions)
    * [Getting a dataset](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#getting-a-dataset)
    * [Inserting the data](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#inserting-the-data)
    * [Picking a set of queries](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#picking-a-set-of-queries)
    * [Running the queries](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#running-the-queries)
  * [Automating our toil](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#automating-our-toil)
  * [Results](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#results)
  * [What does the data tell us?](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#what-does-the-data-tell-us)
  * [Feedback from the other products](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#feedback-from-the-other-products)
    * [Meilisearch](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#meilisearch)
    * [Typesense](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#typesense)
  * [Wrap-up](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#wrap-up)
  * [More Postgres resources](https://supabase.com/blog/postgres-full-text-search-vs-the-rest#more-postgres-resources)


Share this article
[](https://twitter.com/intent/tweet?url=https%3A%2F%2Fsupabase.com%2Fblog%2Fpostgres-full-text-search-vs-the-rest&text=Postgres%20Full%20Text%20Search%20vs%20the%20rest)[](https://www.linkedin.com/shareArticle?url=https%3A%2F%2Fsupabase.com%2Fblog%2Fpostgres-full-text-search-vs-the-rest&text=Postgres%20Full%20Text%20Search%20vs%20the%20rest)[](https://news.ycombinator.com/submitlink?u=https%3A%2F%2Fsupabase.com%2Fblog%2Fpostgres-full-text-search-vs-the-rest&t=Postgres%20Full%20Text%20Search%20vs%20the%20rest)
## Build in a weekend, scale to millions
[Start your project](https://supabase.com/dashboard)[Request a demo](https://supabase.com/contact/sales)
## Footer
We protect your data.[More on Security](https://supabase.com/security)
  * SOC2 Type 2 Certified
  * HIPAA Compliant


[![Supabase Logo](https://supabase.com/_next/image?url=https%3A%2F%2Ffrontend-assets.supabase.com%2Fwww%2Fd218d9190b87%2F_next%2Fstatic%2Fmedia%2Fsupabase-logo-wordmark--light.daaeffd3.png&w=384&q=75&dpl=dpl_9xPTPeSUKoDuygMmT5sPj6DB4mgG)![Supabase Logo](https://supabase.com/_next/image?url=https%3A%2F%2Ffrontend-assets.supabase.com%2Fwww%2Fd218d9190b87%2F_next%2Fstatic%2Fmedia%2Fsupabase-logo-wordmark--dark.b36ebb5f.png&w=384&q=75&dpl=dpl_9xPTPeSUKoDuygMmT5sPj6DB4mgG)](https://supabase.com/)
[Twitter](https://twitter.com/supabase)[GitHub](https://github.com/supabase)[Discord](https://discord.supabase.com/)[Youtube](https://youtube.com/c/supabase)
###### Product
  * [Database](https://supabase.com/database)
  * [Auth](https://supabase.com/auth)
  * [Functions](https://supabase.com/edge-functions)
  * [Realtime](https://supabase.com/realtime)
  * [Storage](https://supabase.com/storage)
  * [Vector](https://supabase.com/modules/vector)
  * [Cron](https://supabase.com/modules/cron)
  * [Pricing](https://supabase.com/pricing)
  * [Launch Week](https://supabase.com/launch-week)
  * [AI Builders](https://supabase.com/solutions/ai-builders)


###### Resources
  * [Support](https://supabase.com/support)
  * [System Status](https://status.supabase.com/)
  * [Become a Partner](https://supabase.com/partners)
  * [Integrations](https://supabase.com/partners/integrations)
  * [Brand Assets / Logos](https://supabase.com/brand-assets)
  * [Security and Compliance](https://supabase.com/security)
  * [DPA](https://supabase.com/legal/dpa)
  * [SOC2](https://supabase.com/security)
  * [HIPAA](https://forms.supabase.com/hipaa2)


###### Developers
  * [Documentation](https://supabase.com/docs)
  * [Supabase UI](https://supabase.com/ui)
  * [Changelog](https://supabase.com/changelog)
  * [Contributing](https://github.com/supabase/supabase/blob/master/CONTRIBUTING.md)
  * [Open Source](https://supabase.com/open-source)
  * [SupaSquad](https://supabase.com/supasquad)
  * [DevTo](https://dev.to/supabase)
  * [RSS](https://supabase.com/rss.xml)


###### Company
  * [Blog](https://supabase.com/blog)
  * [Customer Stories](https://supabase.com/customers)
  * [Careers](https://supabase.com/careers)
  * [Company](https://supabase.com/company)
  * [Events & Webinars](https://supabase.com/events)
  * [General Availability](https://supabase.com/ga)
  * [Terms of Service](https://supabase.com/terms)
  * [Privacy Policy](https://supabase.com/privacy)
  * Privacy Settings
  * [Acceptable Use Policy](https://supabase.com/aup)
  * [Support Policy](https://supabase.com/support-policy)
  * [Service Level Agreement](https://supabase.com/sla)
  * [Humans.txt](https://supabase.com/humans.txt)
  * [Lawyers.txt](https://supabase.com/lawyers.txt)
  * [Security.txt](https://supabase.com/.well-known/security.txt)


© Supabase Inc
Toggle theme
awakening

